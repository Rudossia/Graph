# Graph Library

Полная документация к библиотеке **Graph** на языке C для работы с неориентированными графами и решения прикладных задач на родословных деревьях.

---

## Оглавление

1. [Описание проекта](#описание-проекта)
2. [Ключевые возможности](#ключевые-возможности)
3. [Структуры данных](#структуры-данных)
4. [Алгоритмы и сценарии использования](#алгоритмы-и-сценарии-использования)
5. [Чтение и запись файлов](#чтение-и-запись-файлов)
6. [Установка и сборка](#установка-и-сборка)
7. [Примеры использования](#примеры-использования)
8. [Тестирование](#тестирование)
9. [Управление памятью и обработка ошибок](#управление-памятью-и-обработка-ошибок)
10. [Настройка и расширение](#настройка-и-расширение)
11. [Стиль кодирования](#стиль-кодирования)
12. [Вклад и лицензия](#вклад-и-лицензия)

---

## Описание проекта

Библиотека **Graph** позволяет:

* Создавать и модифицировать неориентированные графы с динамическими списками смежности.
* Хранить в вершинах персональные данные (имя, пол, годы жизни).
* Выполнять классические алгоритмы на графах (BFS, поиск кратчайших путей, Floyd–Warshall).
* Решать задачу распределения наследства по родословному древу с указанием долей.
* Экспортировать структуру в формат DOT для визуализации через Graphviz.

Целевая аудитория: студенты, преподаватели, разработчики С-проектов, работающих с деревьями наследования или генеалогией.

## Ключевые возможности

1. **Динамическое управление** памятью: автоматическое перераспределение массивов при росте числа вершин.
2. **Обширный набор алгоритмов**:

   * Обход в ширину (BFS).
   * Поиск кратчайшего пути (единый вес).
   * Алгоритм Флойда–Уоршелла для всех пар.
3. **Специальный модуль наследства**:

   * Расчет долей по вероятностной модели (0.5^длина пути).
   * Возможность добавить информацию о наследстве в имена вершин.
4. **Поддержка ввода/вывода**:

   * Чтение из текстового файла с гибким форматом.
   * Экспорт в DOT и автоматическое создание PNG при наличии утилиты **dot**.
5. **Интеграция** с CLI-приложением под **main.c** для интерактивной работы.

## Структуры данных

```c
// Пол
typedef enum Gender { MALE, FEMALE } Gender;

// Вершина графа
typedef struct Vertex {
    char*   name;        // Динамически выделяемое полное имя
    Gender  gender;      // Пол
    int     birth_year;  // Год рождения (0 для незаполненного)
    int     death_year;  // Год смерти (0 для незаполненного)
} Vertex;

// Элемент списка смежности
typedef struct Edge {
    int      vertex1;    // От кого
    int      vertex2;    // Кому
    struct Edge* next;   // Следующее ребро
} Edge;

// Основная структура графа
typedef struct Graph {
    Vertex* vertices;        // Массив вершин
    int     vertex_count;    // Текущее число вершин
    int     vertex_capacity; // Общая ёмкость массива
    Edge**  adjacency_list;  // Массив списков смежности
} Graph;
```

## Алгоритмы и сценарии использования

### Обход в ширину (BFS)

```c
void bfs(Graph* graph, const char* start_name);
```

* Печатает порядок посещения вершин.
* Логика: очередь, массив посещений.

### Поиск кратчайшего пути

```c
void shortest_path(Graph* graph, const char* from, const char* to);
```

* Без весов: каждая грань = 1.
* Выводит длину и сам маршрут.

### Floyd–Warshall

```c
void floyd_warshall(Graph* graph, int** dist);
```

* Заполняет матрицу **dist** попарных расстояний.

### Распределение наследства

```c
double* distribute_inheritance(Graph* graph,
                                const char* ancestor,
                                double amount,
                                bool silent,
                                bool no_return);
```

* Находит всех «потомков» (рёбра > 0, death\_year > death предка).
* Распределяет сумму пропорционально 0.5^d, где **d** = длина пути.
* silent = true подавляет печать в консоль.
* no\_return = true освобождает массив долей.

### Экспорт Graphviz

```c
void graphviz_output(Graph* graph, const char* filename);
```

* Генерация файла `.dot`.
* При наличии `dot` можно сразу делать `PNG`.

## Чтение и запись файлов

**Формат текстового файла** для `read_graph_from_file`:

1. Первая строка — число вершин **N**.
2. Следующие **N** строк:

   ```text
   Фамилия Имя Отчество,Пол,ГодРождения,ГодСмерти
   ```

   * Пол: `M` или `F`, года — целые.
3. Затем строки ребёр:

   ```text
   ПолноеИмя1,ПолноеИмя2
   ```

**Пример**:

```text
5
Иванов Пётр Петрович,M,1950,2000
Иванов Алексей Петрович,M,1975,0
Иванова Анна Петровна,F,1980,0
Петров Пётр Сергеевич,M,1945,1990
Петрова Мария Петровна,F,1970,0
Иванов Пётр Петрович,Иванов Алексей Петрович
...
```

## Установка и сборка

```bash
# Компиляция с примерами
gcc -std=c99 -O2 -Wall main.c graph.c -o graph_app
```

**Опции**:

* **-O2** — оптимизация скорости.
* **-Wall** — включить все предупреждения.
* **-g** — если нужен отладочный режим.

## Примеры использования

### 1. Ручное взаимодействие

```bash
./graph_app
> 1  # Добавить вершину
Введите имя, пол (0=М,1=Ж), год рождения, год смерти: ...
> 3  # Добавить ребро
> 5  # Печать графа
```

### 2. Автоматическое чтение и вывод

```bash
./graph_app
> 10
family.txt  # Файл родословной
100000      # Сумма наследства
inheritance.dot
# dot -Tpng inheritance.dot -o result.png
```

## Тестирование

* Юнит-тесты на уровне функций (рекомендуется писать с использованием **CUnit** или **Unity**).
* Проверить:

  * Добавление/удаление вершин и рёбер.
  * Правильность алгоритмов BFS, кратчайших путей, Floyd–Warshall.
  * Распределение наследства на небольших деревьях.

## Управление памятью и обработка ошибок

* `malloc`/`realloc`/`calloc` проверяются на `NULL`. При отказе выводится сообщение и программа корректно завершает работу.
* Все динамические массивы и строки освобождаются в `free_graph`:

```c
graph->vertices[i].name  // strdup -> free
Edge* edge                // free для каждого ребра
free(graph->vertices);
free(graph->adjacency_list);
free(graph);
```

## Настройка и расширение

* Можно добавить **взвешенные** рёбра, изменив тип `Edge` и алгоритмы.
* Поддержка **ориентированного** графа через флаги.
* Расширить модель наследства (напр. учитывать выживших детей без рёбер).
* Интерфейс взаимодействия: добавить опцию скриптовой обработки файлов (бесплатный входной/выходной поток).

## Стиль кодирования

* **C99** с явным указанием типов.
* **snake\_case** для функций и переменных.
* **K\&R** brace style:

```c
if (condition) {
    // code
} else {
    // code
}
```

* Комментарии на русском языке в ключевых местах.

## Вклад

Этот проект распространяется под лицензией **MIT**.

1. Форкните репозиторий.
2. Создайте ветку для своей фичи: `git checkout -b feature/...`.
3. Сделайте коммиты с описательными сообщениями.
4. Откройте Pull Request.

---
